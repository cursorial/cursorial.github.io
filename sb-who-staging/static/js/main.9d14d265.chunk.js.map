{"version":3,"sources":["config.js","api.js","operations/index.js","queryCache.js","operations/resources.js","actions/createProject.js","actions/claimProject.js","actions/unclaimProject.js","queries/getProjects.js","ext-src/MainPage.js","queries/index.js","router.js","serviceWorker.js","index.js"],"names":["config","apiUrl","process","api","axios","create","baseURL","WASP_APP_AUTH_TOKEN_NAME","authToken","window","localStorage","getItem","interceptors","request","use","headers","response","undefined","error","status","removeItem","Promise","reject","handleApiError","responseJson","data","responseStatusCode","e","Error","message","statusCode","callOperation","operationRoute","args","a","post","QueryCache","resourceToQueryCacheKeys","Map","getQueriesUsingResource","resource","Array","from","get","invalidateQueriesUsing","resources","queryCacheKeysToInvalidate","Set","forEach","key","add","queryCacheKey","queryCache","invalidateQueries","createProject","actionResult","entitiesUsed","claimProject","unclaimProject","getProjects","cacheKeys","set","styles","container","padding","margin","display","inputContainer","flexDirection","alignItems","textInput","width","fontSize","textAlign","textInputHint","background","borderRadius","getProjectStyles","isProjectClaimed","baseStyles","MainPage","projects","queryFn","queryFnArgs","rqUseQuery","queryKey","_key","useQuery","React","useState","user","setUser","project","setProject","onClaimClick","id","parseInt","target","value","onUnclaimClick","renderClaimButton","onClick","style","type","placeholder","onChange","length","name","map","router","exact","path","component","Main","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9d14d265.chunk.js","sourcesContent":["\nconst config = {\n  apiUrl: process.env.REACT_APP_API_URL || 'http://localhost:3001'\n}\n\nexport default config\n","import axios from 'axios'\nimport config from './config'\n\nconst api = axios.create({\n  baseURL: config.apiUrl,\n})\n\nconst WASP_APP_AUTH_TOKEN_NAME = \"authToken\"\n\nlet authToken = null\nif (window.localStorage) {\n  authToken = window.localStorage.getItem(WASP_APP_AUTH_TOKEN_NAME)\n}\n\nexport const setAuthToken = (token) => {\n  if (typeof token !== 'string') {\n    throw Error(`Token must be a string, but it was: {${typeof token}} ${token}.`)\n  }\n  authToken = token\n  window.localStorage && window.localStorage.setItem(WASP_APP_AUTH_TOKEN_NAME, token)\n}\n\nexport const clearAuthToken = () => {\n  authToken = undefined\n  window.localStorage && window.localStorage.removeItem(WASP_APP_AUTH_TOKEN_NAME)\n}\n\nexport const clearLocalStorage = () => {\n  authToken = undefined\n\n  window.localStorage && window.localStorage.clear()\n}\n\napi.interceptors.request.use(request => {\n  if (authToken) {\n    request.headers['Authorization'] = `Bearer ${authToken}`\n  }\n  return request\n})\n\napi.interceptors.response.use(undefined, error => {\n  if (error.response?.status === 401) {\n    clearAuthToken()\n  }\n  return Promise.reject(error)\n})\n\n/**\n * Takes an error returned by the app's API (as returned by axios), and transforms into a more\n * standard format to be further used by the client. It is also assumed that given API\n * error has been formatted as implemented by HttpError on the server.\n */\nexport const handleApiError = (error) => {\n  if (error?.response) {\n    // If error came from HTTP response, we capture most informative message\n    // and also add .statusCode information to it.\n    // If error had JSON response, we assume it is of format { message, data } and\n    // add that info to the error.\n    // TODO: We might want to use HttpError here instead of just Error, since\n    //   HttpError is also used on server to throw errors like these.\n    //   That would require copying HttpError code to web-app also and using it here.\n    const responseJson = error.response?.data\n    const responseStatusCode = error.response.status\n    const e = new Error(responseJson?.message || error.message)\n    e.statusCode = responseStatusCode\n    e.data = responseJson?.data\n    throw e\n  } else {\n    // If any other error, we just propagate it.\n    throw error\n  }\n}\n\nexport default api\n","import api, { handleApiError } from '../api.js'\nimport config from '../config.js'\n\nexport const callOperation = async (operationRoute, args) => {\n  try {\n    const response = await api.post(config.apiUrl + '/' + operationRoute, args)\n    return response.data\n  } catch (error) {\n    handleApiError(error)\n  }\n}\n\n","import { QueryCache } from 'react-query'\n\nexport default new QueryCache()\n","import queryCache from '../queryCache'\n\n\n// Map where key is resource name and value is Set\n// containing query ids of all the queries that use\n// that resource.\nconst resourceToQueryCacheKeys = new Map()\n\n/**\n * Remembers that specified query is using specified resources.\n * If called multiple times for same query, resources are added, not reset.\n * @param {string} queryCacheKey - Unique key under used to identify query in the cache.\n * @param {string[]} resources - Names of resources that query is using.\n */\nexport const addResourcesUsedByQuery = (queryCacheKey, resources) => {\n  for (const resource of resources) {\n    let cacheKeys = resourceToQueryCacheKeys.get(resource)\n    if (!cacheKeys) {\n      cacheKeys = new Set()\n      resourceToQueryCacheKeys.set(resource, cacheKeys)\n    }\n    cacheKeys.add(queryCacheKey)\n  }\n}\n\n/**\n * @param {string} resource - Resource name.\n * @returns {string[]} Array of \"query cache keys\" of queries that use specified resource.\n */\nexport const getQueriesUsingResource = (resource) => {\n  return Array.from(resourceToQueryCacheKeys.get(resource) || [])\n}\n\n/**\n * Invalidates all queries that are using specified resources.\n * @param {string[]} resources - Names of resources.\n */\nexport const invalidateQueriesUsing = (resources) => {\n  const queryCacheKeysToInvalidate = new Set()\n  for (const resource of resources) {\n    getQueriesUsingResource(resource).forEach(key => queryCacheKeysToInvalidate.add(key))\n  }\n  for (const queryCacheKey of queryCacheKeysToInvalidate) {\n    queryCache.invalidateQueries(queryCacheKey)\n  }\n}\n","import { callOperation } from '../operations'\nimport * as resources from '../operations/resources'\n\nconst createProject = async (args) => {\n  const actionResult = await callOperation('operations/create-project', args)\n  resources.invalidateQueriesUsing(entitiesUsed)\n  return actionResult\n}\n\nexport const entitiesUsed = ['Project']\n\nexport default createProject\n\n\n","import { callOperation } from '../operations'\nimport * as resources from '../operations/resources'\n\nconst claimProject = async (args) => {\n  const actionResult = await callOperation('operations/claim-project', args)\n  resources.invalidateQueriesUsing(entitiesUsed)\n  return actionResult\n}\n\nexport const entitiesUsed = ['Project']\n\nexport default claimProject\n\n\n","import { callOperation } from '../operations'\nimport * as resources from '../operations/resources'\n\nconst unclaimProject = async (args) => {\n  const actionResult = await callOperation('operations/unclaim-project', args)\n  resources.invalidateQueriesUsing(entitiesUsed)\n  return actionResult\n}\n\nexport const entitiesUsed = ['Project']\n\nexport default unclaimProject\n\n\n","import { callOperation } from '../operations'\nimport * as resources from '../operations/resources'\n\nconst getProjects = async (args) => {\n  return await callOperation('operations/get-projects', args)\n}\n\nconst queryCacheKey = 'operations/get-projects'\ngetProjects.queryCacheKey = queryCacheKey\n\nexport const entitiesUsed = ['Project']\nresources.addResourcesUsedByQuery(queryCacheKey, entitiesUsed)\n\nexport default getProjects\n\n","import React from 'react'\nimport createProject from '../actions/createProject'\nimport claimProject from '../actions/claimProject'\nimport unclaimProject from '../actions/unclaimProject'\nimport getProjects from '../queries/getProjects'\nimport { useQuery } from '../queries'\n\n\nconst MainPage = () => {\n  const { data: projects } = useQuery(getProjects)\n  const [user, setUser] = React.useState('default')\n  const [project, setProject] = React.useState('')\n\n  const isProjectClaimed = (project) => {\n    return !!project.user\n  }\n  \n  const onAddProject = () => {\n    if (project.length < 5) return null\n    createProject({ name: project })\n    setProject('')\n  }\n\n  const onClaimClick = (e) => {\n    claimProject({ id: parseInt(e.target.value), user: user })\n  }\n\n  const onUnclaimClick = (e) => {\n    unclaimProject({ id: parseInt(e.target.value), user: user })\n  }\n\n  const renderClaimButton = (project) => {\n    if (!(project.user === user || project.user === '')) return null\n    return (\n      <button\n        value={project.id}\n        onClick={isProjectClaimed(project) ? onUnclaimClick : onClaimClick}\n      >\n        {isProjectClaimed(project) ? 'Unclaim' : 'Claim'}\n      </button>\n    )\n  }\n\n  const renderProject = (project) => (\n    <div style={styles.getProjectStyles(isProjectClaimed(project))} key={project.id}>\n      <p>{project.name}</p>\n      <p>{project.user ? project.user : 'Unclaimed'}</p>\n      {renderClaimButton(project)}\n    </div>\n  ) \n\n  return (\n    <>\n      <div style={{\n        ...styles.container,\n        ...styles.inputContainer\n      }}>\n        <input style={styles.textInput} type='text' placeholder='Name' value={user} onChange={e => setUser(e.target.value)} />\n        <p style={styles.textInputHint}>Please ensure you enter your full name to avoid confusion</p>\n      </div>\n      <div style={{\n        ...styles.container,\n        ...styles.inputContainer\n      }}>\n        <input style={styles.textInput} type='text' placeholder='Project Name' value={project} onChange={e => setProject(e.target.value)} />\n        <button onClick={onAddProject}>Add Project</button>\n        <p style={styles.textInputHint}>Please check this project does not already exist before creating one</p>\n      </div>\n      <div style={styles.container}>\n        {projects ? projects.map(renderProject) : null}\n      </div>\n    </>\n  )\n}\n\nconst styles = {\n  container: {\n    padding: '10px',\n    margin: '10px',\n    display: 'flex'\n  },\n  inputContainer: {\n    flexDirection: 'column',\n    alignItems: 'center'\n  },\n  textInput: {\n    width: '80%',\n    fontSize: '30px',\n    textAlign: 'center'\n  },\n  textInputHint: {\n    background: '#ffeeee',\n    padding: '10px',\n    borderRadius: '10px'\n  },\n  getProjectStyles: (isProjectClaimed) => {\n    const baseStyles = {\n      padding: '20px',\n      margin: '10px',\n      borderRadius: '10px'\n    }\n    if (isProjectClaimed) return {\n      ...baseStyles,\n      ...{ background: '#ffeeee' }\n    }\n    return {\n      ...baseStyles,\n      ...{ background: '#eeffee' }\n    }\n  }\n}\n\nexport default MainPage\n","import { useQuery as rqUseQuery } from 'react-query'\n\nexport const useQuery = (queryFn, queryFnArgs, config) => {\n  if (typeof queryFn !== 'function') {\n    throw new Error('useQuery requires queryFn to be a function.')\n  }\n  if (!queryFn.queryCacheKey) {\n    throw new Error('queryFn needs to have queryCacheKey property defined.')\n  }\n\n  const rqResult = rqUseQuery({\n    queryKey: [queryFn.queryCacheKey, queryFnArgs],\n    queryFn: (_key, args) => queryFn(args),\n    config\n  })\n\n  return rqResult\n}\n","import React from 'react'\nimport { Route, BrowserRouter as Router } from 'react-router-dom'\n\n\nimport Main from \"./ext-src/MainPage.js\"\n\n\nconst router = (\n  <Router>\n    <div>\n      <Route exact path=\"/\" component={ Main }/>\n    </div>\n  </Router>\n)\n\nexport default router\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { ReactQueryCacheProvider } from 'react-query'\n\nimport router from './router'\nimport queryCache from './queryCache'\nimport * as serviceWorker from './serviceWorker'\n\nimport './index.css'\n\n\nReactDOM.render(\n  <ReactQueryCacheProvider queryCache={queryCache}>\n    { router }\n  </ReactQueryCacheProvider>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}